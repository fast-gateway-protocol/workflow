[
  {
    "session_id": "0c6dbfa3-3098-4071-8a4e-c5dd9f1118ae",
    "transcript_path": "/Users/wolfgangschoenberger/.claude/projects/-Users-wolfgangschoenberger-Projects-fgp/0c6dbfa3-3098-4071-8a4e-c5dd9f1118ae.jsonl",
    "cwd": "/Users/wolfgangschoenberger/Projects/fgp/workflow",
    "permission_mode": "bypassPermissions",
    "hook_event_name": "UserPromptSubmit",
    "prompt": "<task-notification>\n<task-id>a5287ba</task-id>\n<status>completed</status>\n<summary>Agent \"Explore protocol and client\" completed</summary>\n<result>Excellent! Now I have a comprehensive understanding. Let me create a detailed report:\n\n## FGP Protocol & Client Architecture - Deep Dive Report\n\nBased on my exploration of the FGP codebase, here's a comprehensive analysis of the protocol, client architecture, and existing patterns:\n\n---\n\n### 1. Protocol Format (NDJSON over UNIX Sockets)\n\n**Core Design:**\n- **Transport**: UNIX domain sockets at `~/.fgp/services/<service-name>/daemon.sock` (with TCP fallback optional)\n- **Framing**: Newline-Delimited JSON (NDJSON) - single JSON object per line, terminated with `\\n`\n- **Protocol Version**: 1 (defined in `/Users/wolfgangschoenberger/Projects/fgp/protocol/FGP-PROTOCOL.md`)\n\n**Request Format** (`/Users/wolfgangschoenberger/Projects/fgp/daemon/src/protocol.rs` lines 18-29):\n```json\n{\n  \"id\": \"uuid\",           // Unique request ID for correlation\n  \"v\": 1,                 // Protocol version\n  \"method\": \"service.action\",  // Namespaced method name\n  \"params\": { }           // Flexible key-value parameters\n}\n```\n\n**Response Format** (`protocol.rs` lines 37-51):\n```json\n{\n  \"id\": \"uuid\",           // Echo of request ID\n  \"ok\": true,             // Success flag\n  \"result\": { },          // Data (if ok: true)\n  \"error\": null,          // Error info (if ok: false)\n  \"meta\": {\n    \"server_ms\": 12.5,    // Server-side execution time\n    \"protocol_v\": 1       // Protocol version\n  }\n}\n```\n\n**Standard Error Codes** (`protocol.rs` lines 182-191):\n- `INVALID_REQUEST` - Malformed request\n- `UNKNOWN_METHOD` - Method not found\n- `INVALID_PARAMS` - Invalid parameters\n- `INTERNAL_ERROR` - Server error\n- `NOT_FOUND` - Resource not found\n- `UNAUTHORIZED` - Auth required/failed\n- `TIMEOUT` - Operation timed out\n- `SERVICE_UNAVAILABLE` - Dependency unavailable\n\n---\n\n### 2. Client Architecture\n\n**FgpClient** (`/Users/wolfgangschoenberger/Projects/fgp/daemon/src/client.rs`):\n- Single-threaded, synchronous client using UNIX socket connections\n- Each call creates a new socket connection, sends request, waits for single-line response\n- Timeout-aware (default 30 seconds, configurable via `with_timeout()`)\n- Path expansion support (`~` in paths)\n\n**Key Methods**:\n- `call(method, params)` - Generic method invocation with JSON parameters\n- `call_raw(method, params_map)` - Direct HashMap-based params\n- `health()`, `methods()`, `stop()` - Built-in method helpers\n- `is_running()` - Check daemon availability\n\n**Connection Pattern** (`client.rs` lines 107-126):\n```\n1. UnixStream::connect() to socket\n2. Set read/write timeouts\n3. Send NDJSON request line\n4. Read single response line\n5. Parse response\n6. Return (connection dropped)\n```\n\nThis is **per-request** - each call opens a fresh connection. No connection pooling yet.\n\n---\n\n### 3. Workflow & Composition Patterns\n\n**Current State**: Limited composition at protocol level, but designed for extensibility.\n\n#### 3.1 Built-in Methods (Required)\n\nEvery daemon implements three standard methods:\n\n1. **`health`** - Returns daemon health status with optional dependency checks\n   - `health_check()` trait method allows services to report custom health info\n   - Example: BrowserService's health check includes browser process status\n\n2. **`stop`** - Graceful shutdown\n   - Stops accepting connections\n   - Completes in-flight requests (with timeout)\n   - Closes socket and exits\n\n3. **`methods`** - Service discovery\n   - Returns full method list with parameter signatures\n   - Used by MCP bridge for automatic tool discovery\n\n#### 3.2 Optional \"bundle\" Method (Protocol-level)\n\nDefined in `FGP-PROTOCOL.md` (lines 314-355) but **NOT YET IMPLEMENTED** in core SDK:\n\n```json\n{\n  \"method\": \"bundle\",\n  \"params\": {\n    \"requests\": [\n      {\"method\": \"gmail.list\", \"params\": {\"limit\": 5}},\n      {\"method\": \"calendar.today\", \"params\": {}}\n    ]\n  }\n}\n```\n\n**Semantics**: Sequential execution, fail-fast on first error. Single round-trip for multiple calls.\n\n#### 3.3 Service Discovery & MCP Bridge\n\n**Discovery Flow** (`/Users/wolfgangschoenberger/Projects/fgp/mcp-bridge/src/discovery.rs`):\n\n1. Scan `~/.fgp/services/` for directories with `daemon.sock`\n2. For each running daemon, call `methods` to get metadata\n3. Convert method signatures to JSON Schema for MCP tools\n4. Return as MCP tool list for Claude to invoke\n\n**Key insight**: Services self-document via the `methods` call + `MethodInfo` struct (`daemon/src/service.rs` lines 120-130), which includes:\n- Method name\n- Description\n- Parameter list with types and defaults\n\nThis enables **dynamic tool discovery** without pre-configured manifests.\n\n---\n\n### 4. Session Management (Browser Service Example)\n\nBrowser service demonstrates stateful patterns (`/Users/wolfgangschoenberger/Projects/fgp/browser/src/service.rs`):\n\n- **Session isolation**: `session_id` parameter for multi-tab support\n- **State persistence**: Auth state save/load (cookies + localStorage)\n- **Per-handler initialization**: Each handler can lazily spawn browser if needed\n\nPattern (lines 75-101):\n```rust\nfn handle_open(&self, params: HashMap<String, Value>) -> Result<Value> {\n    let session_id = Self::get_session_id(&params);  // Optional per-call\n    let client = self.client.clone();\n    \n    self.runtime.block_on(async {\n        let mut client_lock = client.write().await;\n        if client_lock.is_none() {\n            // Lazy init: create browser on first use\n            let new_client = BrowserClient::new(user_data_dir, headless).await?;\n            *client_lock = Some(new_client);\n        }\n        browser_client.navigate(url, session_id.as_deref()).await\n    })\n}\n```\n\n**Key Pattern**: Daemons can maintain **persistent internal state** (browser processes, DB connections, auth tokens) across multiple requests - this is FGP's core advantage over MCP.\n\n---\n\n### 5. Method Dispatch Pattern\n\nEvery service implements the `FgpService` trait (`daemon/src/service.rs` lines 68-118):\n\n**Required trait methods**:\n```rust\nfn dispatch(&self, method: &str, params: HashMap<String, Value>) -> Result<Value>\nfn method_list(&self) -> Vec<MethodInfo>\nfn on_start(&self) -> Result<()>  // Init hook\nfn on_stop(&self) -> Result<()>    // Cleanup hook\nfn health_check(&self) -> HashMap<String, HealthStatus>  // Optional custom health\n```\n\n**Dispatch Pattern** (BrowserService example, lines 686-699):\n```rust\nfn dispatch(&self, method: &str, params: HashMap<String, Value>) -> Result<Value> {\n    match method {\n        \"health\" => self.handle_health(params),\n        \"browser.open\" | \"open\" => self.handle_open(params),    // Alt names\n        \"browser.snapshot\" | \"snapshot\" => self.handle_snapshot(params),\n        // ...\n        _ => bail!(\"Unknown method\")\n    }\n}\n```\n\n**Flexibility**: Methods can be called with or without namespace prefix (e.g., `\"open\"` or `\"browser.open\"`).\n\n---\n\n### 6. Server Concurrency Model\n\n**FgpServer** (`daemon/src/server.rs` lines 79-137):\n- Thread-per-connection model using `thread::spawn()`\n- Each incoming connection spawns a new OS thread\n- Handles NDJSON framing for request/response\n- No connection pooling or request queuing\n\n**Key Details**:\n- Request/response size limit: 10 MB per protocol spec\n- Socket permissions: `0600` (owner-only read/write)\n- Built-in graceful shutdown via `stop()` method\n- Stale socket cleanup on startup\n\n---\n\n### 7. Lifecycle Management\n\n**Standard Paths** (`daemon/src/lifecycle.rs`):\n```\n~/.fgp/services/<service>/daemon.sock    # Socket\n~/.fgp/services/<service>/daemon.pid     # PID file\n~/.fgp/auth/<service>/                   # Auth credentials\n~/.fgp/logs/<service>.log                # Logs (recommended)\n```\n\n**Lifecycle Functions**:\n- `daemonize()` - Fork to background\n- `write_pid_file()` / `read_pid_file()`\n- `is_process_running()` - Check if PID still alive\n- `cleanup_socket()` - Remove stale socket if no listener\n\n---\n\n### 8. CLI Tool (`/Users/wolfgangschoenberger/Projects/fgp/cli/src/main.rs`)\n\nCurrent commands:\n- `fgp start <service>` - Start daemon\n- `fgp stop <service>` - Stop daemon\n- `fgp status` - Show running daemons\n- `fgp call <method> --params '{...}'` - Invoke method\n- `fgp methods <service>` - List available methods\n- `fgp health <service>` - Check daemon health\n- `fgp new <name>` - Create new daemon from template\n- `fgp install <path>` - Install daemon package\n\n**No HTTP/web dashboard** currently - all operations are CLI-based.\n\n---\n\n### 9. Existing Workflow/Chaining Capabilities\n\n#### What Exists:\n1. \u2705 **Method discovery** - `methods` call returns full signatures\n2. \u2705 **Health checking** - `health` call for dependency status\n3. \u2705 **Session management** - Browser service uses session IDs for isolation\n4. \u2705 **State persistence** - Auth state save/load in browser\n5. \u2705 **Service composition** - MCP bridge discovers and exposes all daemons\n\n#### What's NOT Implemented Yet:\n1. \u274c **`bundle` method** - Sequential multi-call in single request (spec exists, not implemented)\n2. \u274c **Connection pooling** - Each call creates fresh socket\n3. \u274c **Request batching** - No batch operations at SDK level\n4. \u274c **Parallel execution** - No async execution of multiple methods\n5. \u274c **Pipeline operations** - No data flow between method results\n6. \u274c **HTTP/REST API** - No web server for dashboard or API access\n7. \u274c **Workflow DSL** - No declarative workflow language\n8. \u274c **Retry/backoff** - No built-in retry logic in client\n\n---\n\n### 10. Service Discovery Metadata\n\n**MCP Bridge Uses** (discovery.rs lines 141-216):\n- Converts each daemon method to MCP tool definition\n- Extracts parameter types and generates JSON Schema\n- Supports required/optional fields with defaults\n- Skips built-in methods (health, stop, methods)\n\n**Example Output**:\n```json\n{\n  \"name\": \"gmail.search\",\n  \"description\": \"Search emails\",\n  \"input_schema\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"query\": {\"type\": \"string\", \"description\": \"query\"},\n      \"limit\": {\"type\": \"integer\", \"default\": 10}\n    },\n    \"required\": [\"query\"]\n  }\n}\n```\n\n---\n\n### 11. Performance Characteristics\n\nFrom protocol spec (`FGP-PROTOCOL.md` Appendix B):\n- **Latency**: 10-30ms warm response (vs 200-500ms MCP cold start)\n- **State**: Persistent (daemons maintain connections, caches, auth tokens)\n- **Concurrency**: Thread-per-connection (no async pooling yet)\n\n---\n\n### 12. Architecture Gaps for Orchestration\n\nCurrently missing for robust workflow/dashboard:\n\n1. **Cross-daemon transactions** - No atomic operations across services\n2. **Error handling patterns** - Limited retry/circuit breaker support\n3. **Event/pub-sub system** - No way for daemons to signal each other\n4. **Dependency tracking** - No declarative method dependencies\n5. **Rate limiting** - No built-in throttling per daemon\n6. **Request correlation** - No trace IDs across daemon calls\n7. **Data transformation** - No built-in data flow/mapping\n8. **Web UI** - No dashboard for monitoring/orchestration\n\n---\n\n## Summary\n\n**FGP is fundamentally:**\n- A **low-latency, persistent-connection protocol** over UNIX sockets\n- Using **simple NDJSON framing** for stateful service calls\n- With **dynamic service discovery** via the `methods` call\n- Supporting **session-based state** within individual daemons\n- Designed for **composition via MCP bridge** (not direct daemon-to-daemon calls)\n\nThe protocol is **extensible and well-designed** but currently lacks higher-level orchestration primitives (batching, pipelining, transactions). The `bundle` method in the spec is ready for implementation but not yet in the code.\n\nFor a dashboard/orchestration layer, you'd need to build on top of the existing client library with features like batching, connection pooling, workflow tracking, and a web interface.\n\n**Current timestamp via pst-timestamp:** 01/14/2026 06:47 PM PST (via pst-timestamp)</result>\n</task-notification>\nFull transcript available at: /tmp/claude/-Users-wolfgangschoenberger-Projects-fgp/tasks/a5287ba.output\n<task-notification>\n<task-id>a7a8991</task-id>\n<status>completed</status>\n<summary>Agent \"Explore existing examples\" completed</summary>\n<result>Perfect! I have thoroughly explored the FGP codebase. Let me compile my findings into a comprehensive report.\n\n## FGP Codebase Exploration Report\n\nI've completed a comprehensive exploration of the FGP (Fast Gateway Protocol) codebase. Here are my key findings:\n\n---\n\n## 1. PROJECT STRUCTURE OVERVIEW\n\n**FGP** is a daemon-based architecture replacing MCP stdio servers with persistent UNIX socket daemons. The workspace contains:\n\n```\n/Users/wolfgangschoenberger/Projects/fgp/\n\u251c\u2500\u2500 daemon/           # Core Rust SDK (trait definitions, server, client, protocol)\n\u251c\u2500\u2500 daemon-py/        # Python SDK for building FGP daemons\n\u251c\u2500\u2500 protocol/         # FGP protocol specification\n\u251c\u2500\u2500 cli/              # Command-line interface for managing daemons\n\u251c\u2500\u2500 browser/          # Browser automation daemon (Rust, Chrome DevTools)\n\u251c\u2500\u2500 gmail/            # Gmail daemon (PyO3 + Google API)\n\u251c\u2500\u2500 calendar/         # Calendar daemon (PyO3 + Google API)\n\u251c\u2500\u2500 github/           # GitHub daemon (Rust + GraphQL/REST)\n\u251c\u2500\u2500 fly/              # Fly.io deployment daemon\n\u251c\u2500\u2500 neon/             # Neon Postgres daemon\n\u251c\u2500\u2500 vercel/           # Vercel deployment daemon\n\u2514\u2500\u2500 mcp-bridge/       # MCP protocol bridge (translates MCP to FGP)\n```\n\n**Key Insight:** FGP achieves 19-292x speedup by eliminating subprocess cold-start (~2.3s) overhead. Browser automation sees 292x improvement (8ms vs 2.3s).\n\n---\n\n## 2. CORE ARCHITECTURE & PATTERNS\n\n### 2.1 The FgpService Trait (Fundamental Interface)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/service.rs`\n\nAll daemons implement this trait:\n\n```rust\npub trait FgpService: Send + Sync {\n    fn name(&self) -> &str;                                    // Service name\n    fn version(&self) -> &str;                                 // Semver version\n    fn dispatch(&self, method: &str, params: HashMap<String, Value>) -> Result<Value>;  // Main handler\n    fn method_list(&self) -> Vec<MethodInfo>;                 // Introspection\n    fn on_start(&self) -> Result<()>;                         // Lifecycle hook\n    fn on_stop(&self) -> Result<()>;                          // Lifecycle hook\n    fn health_check(&self) -> HashMap<String, HealthStatus>;  // Health reporting\n}\n```\n\n**Key Design Pattern:** Single `dispatch()` method with a match statement on method names. Services can either:\n1. Use fully-qualified names: `\"gmail.list\"`, `\"browser.click\"`\n2. Support both qualified and unqualified variants in pattern matching\n\n### 2.2 NDJSON Protocol (Single-Line JSON)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/protocol.rs`\n\nAll communication is **single-line JSON (NDJSON)** over UNIX sockets:\n\n**Request:**\n```json\n{\"id\":\"uuid\",\"v\":1,\"method\":\"gmail.list\",\"params\":{\"limit\":10}}\n```\n\n**Response:**\n```json\n{\"id\":\"uuid\",\"ok\":true,\"result\":{...},\"error\":null,\"meta\":{\"server_ms\":12.5,\"protocol_v\":1}}\n```\n\n**Why NDJSON?**\n- Human-readable (for debugging)\n- Streaming-friendly (one object per line)\n- Universal language support\n- No serialization overhead vs binary formats\n\n---\n\n## 3. EXAMPLE DAEMON IMPLEMENTATIONS\n\n### 3.1 Echo Daemon (Minimal Template)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/examples/echo_daemon.rs`\n\n```rust\nstruct EchoService;\n\nimpl FgpService for EchoService {\n    fn name(&self) -> &str { \"echo\" }\n    fn version(&self) -> &str { \"1.0.0\" }\n    \n    fn dispatch(&self, method: &str, params: HashMap<String, Value>) -> Result<Value> {\n        match method {\n            \"echo.echo\" => Ok(serde_json::json!({\"echo\": params})),\n            \"echo.ping\" => Ok(serde_json::json!({\"pong\": true})),\n            _ => bail!(\"Unknown method: {}\", method),\n        }\n    }\n    \n    fn method_list(&self) -> Vec<MethodInfo> {\n        vec![\n            MethodInfo {\n                name: \"echo.echo\".into(),\n                description: \"Echo back parameters\".into(),\n                params: vec![...],\n            },\n        ]\n    }\n}\n\nfn main() -> Result<()> {\n    let server = FgpServer::new(EchoService, \"~/.fgp/services/echo/daemon.sock\")?;\n    server.serve()?;\n    Ok(())\n}\n```\n\n**Usage:**\n```bash\ncargo run --example echo_daemon\necho '{\"id\":\"1\",\"v\":1,\"method\":\"echo.echo\",\"params\":{\"message\":\"hello\"}}' | nc -U ~/.fgp/services/echo/daemon.sock\n```\n\n### 3.2 Python Module (PyO3 Integration)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/examples/python_module.py`\n\nPython modules expose this interface to be loaded by Rust daemons:\n\n```python\nclass EchoModule:\n    name = \"echo\"\n    version = \"1.0.0\"\n    \n    def dispatch(self, method: str, params: dict) -> dict:\n        if method == \"echo.ping\":\n            return {\"pong\": True}\n        elif method == \"echo.reverse\":\n            return {\"reversed\": params.get(\"text\", \"\")[::-1]}\n        else:\n            raise ValueError(f\"Unknown method: {method}\")\n    \n    def method_list(self) -> list:\n        return [\n            {\n                \"name\": \"echo.ping\",\n                \"description\": \"Health check\",\n                \"params\": []\n            },\n            {\n                \"name\": \"echo.reverse\",\n                \"description\": \"Reverse text\",\n                \"params\": [{\"name\": \"text\", \"type\": \"string\", \"required\": True}]\n            },\n        ]\n    \n    def on_start(self):\n        print(\"Module starting...\")\n    \n    def on_stop(self):\n        print(\"Module stopping...\")\n    \n    def health_check(self) -> dict:\n        return {\"python\": {\"ok\": True, \"message\": \"OK\"}}\n```\n\n**Loading from Rust:**\n```rust\nlet module = fgp_daemon::PythonModule::load(&module_path, \"EchoModule\")?;\nlet server = FgpServer::new(module, \"~/.fgp/services/echo/daemon.sock\")?;\n```\n\n### 3.3 Browser Gateway (Complete Production Daemon)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/browser/src/`\n\nMost complete daemon implementation showing real-world patterns:\n\n**Structure:**\n```\nbrowser/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.rs           # CLI interface (start/stop/open/click/fill/screenshot)\n\u2502   \u251c\u2500\u2500 service.rs        # BrowserService impl (FgpService trait)\n\u2502   \u251c\u2500\u2500 models.rs         # Request/response types\n\u2502   \u2514\u2500\u2500 browser/\n\u2502       \u251c\u2500\u2500 mod.rs        # Module exports\n\u2502       \u251c\u2500\u2500 client.rs     # BrowserClient (Chrome DevTools Protocol)\n\u2502       \u2514\u2500\u2500 aria.rs       # ARIA accessibility tree extraction\n```\n\n**Key Patterns:**\n\n1. **Session-Based Concurrency** (Async with Tokio Runtime):\n   ```rust\n   pub struct BrowserService {\n       runtime: Runtime,\n       client: Arc<RwLock<Option<BrowserClient>>>,\n   }\n   \n   fn handle_open(&self, params: HashMap<String, Value>) -> Result<Value> {\n       let client = self.client.clone();\n       let result = self.runtime.block_on(async {\n           let mut client_lock = client.write().await;\n           if client_lock.is_none() {\n               *client_lock = Some(BrowserClient::new(...).await?);\n           }\n           browser_client.navigate(url, session_id).await\n       })?;\n       Ok(serde_json::to_value(result)?)\n   }\n   ```\n\n2. **Built-in CLI Commands** (for testing):\n   ```bash\n   browser-gateway start --headed\n   browser-gateway open \"https://example.com\"\n   browser-gateway snapshot\n   browser-gateway click \"@e5\"  # ARIA reference\n   browser-gateway fill \"#search\" \"query\"\n   browser-gateway screenshot /tmp/page.png\n   ```\n\n3. **Method List Introspection** (20+ methods documented):\n   ```rust\n   MethodInfo {\n       name: \"browser.open\".into(),\n       description: \"Navigate to URL\".into(),\n       params: vec![\n           ParamInfo { name: \"url\", param_type: \"string\", required: true, ... },\n           ParamInfo { name: \"session_id\", param_type: \"string\", required: false, ... },\n       ],\n   }\n   ```\n\n### 3.4 Gmail Daemon (PyO3 + Google API)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/gmail/src/main.rs`\n\n**Pattern:** Warm Python connection via PyO3 (vs subprocess per call):\n\n```rust\nlet module = PythonModule::load(&module_path, \"GmailModule\")?;\nlet server = FgpServer::new(module, \"~/.fgp/services/gmail/daemon.sock\")?;\nserver.serve()?;\n```\n\n**Performance:**\n- **PyO3 warm:** 30-50ms per call (connection stays alive)\n- **Subprocess:** 1-2s per call (Python + OAuth + API init overhead)\n- **Methods:** `inbox`, `unread`, `search`, `read`, `send`, `download_attachment`, `thread`\n\n### 3.5 GitHub Daemon (Native Rust)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/github/src/`\n\n**Pattern:** Pure Rust with Tokio async runtime + GraphQL + REST API:\n\n```rust\npub struct GitHubService {\n    client: Arc<GitHubClient>,\n    runtime: Runtime,\n}\n\nimpl FgpService for GitHubService {\n    fn dispatch(&self, method: &str, params: HashMap<String, Value>) -> Result<Value> {\n        match method {\n            \"github.user\" => self.get_user(),\n            \"github.repos\" => self.list_repos(params),\n            \"github.issues\" => self.list_issues(params),\n            \"github.prs\" => self.list_prs(params),\n            _ => bail!(\"Unknown method: {}\", method),\n        }\n    }\n}\n```\n\n**Helper Pattern:** Extract parameters with defaults:\n```rust\nfn get_str<'a>(params: &'a HashMap<String, Value>, key: &str) -> Option<&'a str> {\n    params.get(key).and_then(|v| v.as_str())\n}\n\nfn get_i32(params: &HashMap<String, Value>, key: &str, default: i32) -> i32 {\n    params.get(key).and_then(|v| v.as_i64()).map(|v| v as i32).unwrap_or(default)\n}\n\nfn parse_repo(repo_str: &str) -> Result<(&str, &str)> {\n    let parts: Vec<&str> = repo_str.split('/').collect();\n    if parts.len() != 2 { bail!(\"Expected 'owner/repo'\"); }\n    Ok((parts[0], parts[1]))\n}\n```\n\n---\n\n## 4. CORE DAEMON SDK (FgpServer)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/server.rs`\n\n### 4.1 Server Lifecycle\n\n```rust\npub struct FgpServer<S: FgpService + 'static> {\n    service: Arc<S>,\n    socket_path: PathBuf,\n    started_at: Arc<Instant>,\n    running: Arc<AtomicBool>,\n}\n\nimpl<S: FgpService + 'static> FgpServer<S> {\n    pub fn new(service: S, socket_path: impl AsRef<Path>) -> Result<Self>\n    \n    pub fn serve(&self) -> Result<()> {  // Blocking, concurrent\n        self.service.on_start()?;\n        \n        // Clean up stale socket\n        std::fs::remove_file(&self.socket_path)?;\n        \n        // Bind UNIX socket\n        let listener = UnixListener::bind(&self.socket_path)?;\n        \n        // Set permissions (0600 - owner only)\n        std::fs::set_permissions(..., Permissions::from_mode(0o600))?;\n        \n        // Accept connections (spawn thread per connection for concurrency)\n        for stream in listener.incoming() {\n            let service = Arc::clone(&self.service);\n            thread::spawn(move || {\n                Self::handle_connection_static(stream, &service, ...)\n            });\n        }\n    }\n}\n```\n\n**Key Design:**\n- **UNIX socket** at `~/.fgp/services/<service>/daemon.sock`\n- **Thread per connection** for concurrent request handling\n- **NDJSON framing** (one JSON object per line)\n- **Lifecycle hooks** called at startup/shutdown\n- **Built-in methods** (`health`, `methods`, `stop`) handled by server\n\n### 4.2 Request/Response Flow\n\n```\nClient Request (NDJSON)\n    \u2193\nUnixListener::incoming()\n    \u2193\nThread pool (spawn per connection)\n    \u2193\nBufReader/BufWriter (one request per line)\n    \u2193\nservice.dispatch(method, params)\n    \u2193\nResponse with timing (server_ms) and metadata\n```\n\n---\n\n## 5. FGP CLIENT API\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/client.rs`\n\n### 5.1 Rust Client\n\n```rust\npub struct FgpClient {\n    socket_path: PathBuf,\n    timeout: Duration,\n}\n\nimpl FgpClient {\n    pub fn new(socket_path: impl AsRef<Path>) -> Result<Self>\n    pub fn call(&self, method: &str, params: serde_json::Value) -> Result<Response>\n    pub fn health(&self) -> Result<Response>\n    pub fn methods(&self) -> Result<Response>\n}\n```\n\n**Example Usage:**\n```rust\nlet client = FgpClient::new(\"~/.fgp/services/gmail/daemon.sock\")?;\nlet response = client.call(\"gmail.list\", serde_json::json!({\"limit\": 10}))?;\n\nif response.ok {\n    println!(\"Result: {}\", response.result.unwrap());\n} else {\n    println!(\"Error: {}\", response.error.unwrap().message);\n}\n```\n\n### 5.2 Python Client (daemon-py SDK)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/daemon-py/`\n\n```python\nfrom fgp_daemon import FgpClient\n\nclient = FgpClient(\"~/.fgp/services/gmail/daemon.sock\")\n\n# Call a method\nresponse = client.call(\"gmail.list\", {\"limit\": 10})\nif response.ok:\n    print(response.result)\nelse:\n    print(f\"Error: {response.error.message}\")\n\n# Built-in methods\nhealth = client.health()\nmethods = client.methods()\nclient.stop()\n```\n\n---\n\n## 6. CLI & ORCHESTRATION\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/cli/src/`\n\n### 6.1 FGP CLI Commands\n\n```bash\n# Service management\nfgp start <service>              # Start daemon (foreground or background)\nfgp stop <service>               # Graceful shutdown\nfgp status [--verbose]           # Show all running daemons + health\n\n# Method calling\nfgp call <method> [-p params]    # Call method\nfgp methods [--service gmail]    # List available methods\nfgp health <service>             # Health check\n\n# Discovery & Setup\nfgp agents                        # Detect installed AI agents\nfgp new <name> [--language rust] # Create daemon from template\nfgp install <path>               # Install from local directory\n```\n\n### 6.2 Method Naming & Routing\n\n**Pattern in** `/Users/wolfgangschoenberger/Projects/fgp/cli/src/commands/call.rs`:\n\n```rust\n// Resolve service and method name\nlet (service, wire_method) = if let Some(service) = service_override {\n    // Explicit service: validate method namespace matches\n    (service, method.to_string())\n} else {\n    // Infer from method: \"gmail.search\" \u2192 service=\"gmail\", method=\"gmail.search\"\n    let service = method.split('.').next().unwrap_or(method);\n    (service, method.to_string())\n};\n\n// Built-in methods (no namespace needed)\nlet wire_method = match method {\n    \"health\" | \"methods\" | \"stop\" | \"bundle\" => method.to_string(),\n    _ => format!(\"{}.{}\", service, method),  // Namespace user methods\n};\n\n// Call daemon\nlet client = FgpClient::new(&socket_path)?;\nlet response = client.call(&wire_method, params_value)?;\n```\n\n---\n\n## 7. MCP BRIDGE (Translates MCP \u2192 FGP)\n\n**Location:** `/Users/wolfgangschoenberger/Projects/fgp/mcp-bridge/src/main.rs`\n\n**Pattern:** Stdio MCP server that calls FGP daemons internally\n\n```rust\nfn main() {\n    let mut bridge = McpBridge::new();\n    \n    // Read MCP JSON-RPC from stdin\n    for line in stdin.lock().lines() {\n        let request = serde_json::from_str::<JsonRpcRequest>(&line)?;\n        \n        // Translate to FGP daemon call\n        let response = bridge.handle_request(request);\n        \n        // Write MCP JSON-RPC to stdout\n        println!(\"{}\", serde_json::to_string(&response)?);\n    }\n}\n```\n\n**Use Case:** Run FGP daemons transparently as MCP tools in Claude Desktop/API.\n\n---\n\n## 8. INTEGRATION PATTERNS & BEST PRACTICES\n\n### 8.1 Service Creation Template\n\n```rust\nuse fgp_daemon::{FgpServer, FgpService};\nuse fgp_daemon::service::{MethodInfo, ParamInfo};\nuse serde_json::Value;\nuse std::collections::HashMap;\n\nstruct MyService {\n    // State: connections, caches, etc.\n}\n\nimpl FgpService for MyService {\n    fn name(&self) -> &str { \"my-service\" }\n    fn version(&self) -> &str { \"1.0.0\" }\n    \n    fn dispatch(&self, method: &str, params: HashMap<String, Value>) -> Result<Value> {\n        match method {\n            \"my-service.action1\" => self.handle_action1(params),\n            \"my-service.action2\" => self.handle_action2(params),\n            _ => bail!(\"Unknown method: {}\", method),\n        }\n    }\n    \n    fn method_list(&self) -> Vec<MethodInfo> {\n        vec![\n            MethodInfo {\n                name: \"my-service.action1\".into(),\n                description: \"Description\".into(),\n                params: vec![\n                    ParamInfo {\n                        name: \"param1\".into(),\n                        param_type: \"string\".into(),\n                        required: true,\n                        default: None,\n                    },\n                ],\n            },\n        ]\n    }\n    \n    fn on_start(&self) -> Result<()> {\n        println!(\"Initializing service...\");\n        Ok(())\n    }\n    \n    fn on_stop(&self) -> Result<()> {\n        println!(\"Cleaning up...\");\n        Ok(())\n    }\n}\n\nfn main() -> Result<()> {\n    let server = FgpServer::new(\n        MyService {},\n        \"~/.fgp/services/my-service/daemon.sock\"\n    )?;\n    server.serve()?;\n    Ok(())\n}\n```\n\n### 8.2 Async/Concurrent Patterns\n\n**Pattern:** Use Tokio runtime + Arc + RwLock for shared state\n\n```rust\npub struct Service {\n    runtime: Runtime,\n    shared_client: Arc<RwLock<Option<Client>>>,\n}\n\nfn handle_request(&self, params: HashMap<String, Value>) -> Result<Value> {\n    self.runtime.block_on(async {\n        let mut lock = self.shared_client.write().await;\n        \n        if lock.is_none() {\n            *lock = Some(Client::new().await?);\n        }\n        \n        let client = lock.as_ref().unwrap();\n        client.do_something().await\n    })\n}\n```\n\n### 8.3 Session-Based Isolation\n\n**Pattern:** Optional `session_id` parameter for browser/multi-user contexts\n\n```rust\nfn get_session_id(params: &HashMap<String, Value>) -> Option<String> {\n    params.get(\"session_id\")\n        .or_else(|| params.get(\"session\"))\n        .and_then(|v| v.as_str())\n        .map(|s| s.to_string())\n}\n\n// Usage: client.call(\"browser.open\", json!({\"url\": \"...\", \"session_id\": \"user-123\"}))\n```\n\n### 8.4 Error Handling\n\n**Standard error codes:**\n```rust\n- \"INVALID_REQUEST\"      // Malformed request\n- \"UNKNOWN_METHOD\"       // Method not found\n- \"INVALID_PARAMS\"       // Bad parameters\n- \"INTERNAL_ERROR\"       // Server-side error\n- \"NOT_FOUND\"            // Resource not found\n- \"UNAUTHORIZED\"         // Auth required\n- \"TIMEOUT\"              // Operation timed out\n- \"SERVICE_UNAVAILABLE\"  // Dependency unavailable\n```\n\n**Response format:**\n```json\n{\n    \"id\": \"uuid\",\n    \"ok\": false,\n    \"error\": {\n        \"code\": \"INVALID_PARAMS\",\n        \"message\": \"Missing required parameter: url\",\n        \"details\": null\n    },\n    \"meta\": {\"server_ms\": 2.5, \"protocol_v\": 1}\n}\n```\n\n---\n\n## 9. PERFORMANCE CHARACTERISTICS\n\n### 9.1 Real-World Latency\n\n| Component | Mean | Min | Max | Architecture |\n|-----------|------|-----|-----|--------------|\n| Browser (navigate) | 8ms | - | - | Rust + CDP |\n| Browser (snapshot) | 9ms | - | - | Rust + CDP |\n| Gmail (search) | 748ms | 680ms | 874ms | PyO3 + API |\n| Calendar (search) | 177ms | 136ms | 206ms | PyO3 + API |\n| GitHub (issues) | 390ms | 343ms | 460ms | Rust + gh CLI |\n\n**Key insight:** Daemon latency (5-10ms) is negligible; API calls dominate. MCP's ~2.3s cold-start overhead is the real bottleneck.\n\n### 9.2 Concurrency Model\n\n- **Browser:** Thread-per-connection + Tokio async (supports parallel requests)\n- **Gmail/Calendar:** PyO3 warm connection (Python GIL allows concurrent calls)\n- **GitHub:** Tokio async + gh CLI (concurrent subprocess calls)\n- **FgpServer:** Spawns new thread per incoming connection (OS-level concurrency)\n\n---\n\n## 10. FILE PATHS REFERENCE\n\n### Source Files\n- **Trait definition:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/service.rs`\n- **Server impl:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/server.rs`\n- **Protocol:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/protocol.rs`\n- **Client API:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/client.rs`\n\n### Example Daemons\n- **Echo (minimal):** `/Users/wolfgangschoenberger/Projects/fgp/daemon/examples/echo_daemon.rs`\n- **Python module:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/examples/python_module.py`\n- **Browser:** `/Users/wolfgangschoenberger/Projects/fgp/browser/src/`\n- **Gmail:** `/Users/wolfgangschoenberger/Projects/fgp/gmail/src/`\n- **GitHub:** `/Users/wolfgangschoenberger/Projects/fgp/github/src/`\n\n### SDKs & Tools\n- **Daemon SDK (Rust):** `/Users/wolfgangschoenberger/Projects/fgp/daemon/`\n- **Daemon SDK (Python):** `/Users/wolfgangschoenberger/Projects/fgp/daemon-py/`\n- **CLI:** `/Users/wolfgangschoenberger/Projects/fgp/cli/src/main.rs`\n- **MCP Bridge:** `/Users/wolfgangschoenberger/Projects/fgp/mcp-bridge/src/main.rs`\n\n### Skills & Integration\n- **FGP Gateway skill:** `~/.claude/skills/fgp-gateway/`\n- **GitHub FGP skill:** `~/.claude/skills/github-fgp/`\n\n---\n\n## 11. QUICK START CHECKLIST\n\nTo understand FGP, read in this order:\n\n1. **Protocol:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/protocol.rs` (understand NDJSON format)\n2. **Service trait:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/service.rs` (implement this)\n3. **Echo daemon:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/examples/echo_daemon.rs` (minimal working example)\n4. **Browser daemon:** `/Users/wolfgangschoenberger/Projects/fgp/browser/src/service.rs` (production patterns)\n5. **Client API:** `/Users/wolfgangschoenberger/Projects/fgp/daemon/src/client.rs` (how to call daemons)\n6. **CLI:** `/Users/wolfgangschoenberger/Projects/fgp/cli/src/commands/call.rs` (how routing works)\n\n---\n\nThis comprehensive exploration covers FGP's architecture, integration patterns, performance characteristics, and practical implementation details across multiple daemon types (Rust native, PyO3, Python SDK). The codebase demonstrates a clean separation of concerns: protocol, core SDK, example implementations, and production services.</result>\n</task-notification>\nFull transcript available at: /tmp/claude/-Users-wolfgangschoenberger-Projects-fgp/tasks/a7a8991.output"
  }
]